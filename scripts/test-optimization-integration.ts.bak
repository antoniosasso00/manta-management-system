#!/usr/bin/env tsx
/**
 * Script di test end-to-end per l'integrazione del servizio di ottimizzazione
 * Verifica che tutti i componenti funzionino correttamente insieme
 */

import { PrismaClient } from '@prisma/client';
import fetch from 'node-fetch';

const prisma = new PrismaClient();

// Configurazione
const OPTIMIZATION_SERVICE_URL = process.env.NEXT_PUBLIC_OPTIMIZATION_SERVICE_URL || 'http://localhost:8000/api/v1';
const APP_URL = process.env.NEXTAUTH_URL || 'http://localhost:3000';

// Colori per output
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
};

function log(message: string, color: keyof typeof colors = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

async function testOptimizationService() {
  log('\n=== TEST INTEGRAZIONE SERVIZIO OTTIMIZZAZIONE ===\n', 'blue');

  try {
    // Test 1: Health Check Microservizio
    log('1. Test Health Check Microservizio...', 'yellow');
    const healthResponse = await fetch(`${OPTIMIZATION_SERVICE_URL}/health`);
    if (!healthResponse.ok) {
      throw new Error(`Health check fallito: ${healthResponse.status}`);
    }
    const health = await healthResponse.json();
    log(`   ‚úì Servizio attivo: ${health.service} v${health.version}`, 'green');

    // Test 2: Verifica Dati Database
    log('\n2. Verifica dati nel database...', 'yellow');
    
    // Conta ODL disponibili
    const availableODLs = await prisma.oDL.count({
      where: {
        OR: [
          { status: 'IN_AUTOCLAVE' },
          { status: 'CLEANROOM_COMPLETED' }
        ],
        part: {
          partTools: {
            some: {}
          }
        }
      }
    });
    log(`   ‚úì ODL disponibili per ottimizzazione: ${availableODLs}`, 'green');

    // Conta autoclavi
    const autoclaves = await prisma.autoclave.count({
      where: { isActive: true }
    });
    log(`   ‚úì Autoclavi attive: ${autoclaves}`, 'green');

    if (availableODLs === 0 || autoclaves === 0) {
      log('\n   ‚ö†Ô∏è  Dati insufficienti per test completo', 'yellow');
      log('   Esegui prima: npm run db:seed-complete', 'yellow');
      return;
    }

    // Test 3: Test API Diretta del Microservizio
    log('\n3. Test API diretta microservizio...', 'yellow');
    
    // Prepara dati di test
    const testData = {
      odls: [
        {
          id: 'test-odl-1',
          odl_number: 'TEST-2024-001',
          part_number: 'PN-TEST-001',
          curing_cycle: 'CICLO_TEST',
          vacuum_lines: 2,
          tools: [
            {
              id: 'test-tool-1',
              width: 500,
              height: 600,
              weight: 10
            }
          ]
        }
      ],
      autoclaves: [
        {
          id: 'test-ac-1',
          code: 'AC-TEST',
          width: 1900,
          height: 8000,
          vacuum_lines: 20
        }
      ],
      constraints: {
        min_border_distance: 50,
        min_tool_distance: 30,
        allow_rotation: true
      }
    };

    // Test analisi cicli
    const analysisResponse = await fetch(`${OPTIMIZATION_SERVICE_URL}/optimization/analyze`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(testData)
    });

    if (!analysisResponse.ok) {
      throw new Error(`Analisi fallita: ${analysisResponse.status}`);
    }

    const analysis = await analysisResponse.json();
    log(`   ‚úì Analisi cicli completata: ${analysis.cycle_groups.length} gruppi trovati`, 'green');

    // Test 4: Statistiche Performance
    log('\n4. Test performance algoritmo...', 'yellow');
    
    // Crea dataset pi√π grande
    const perfTestData = {
      ...testData,
      odls: Array.from({ length: 20 }, (_, i) => ({
        id: `perf-odl-${i}`,
        odl_number: `PERF-2024-${i.toString().padStart(3, '0')}`,
        part_number: `PN-PERF-${i}`,
        curing_cycle: i < 10 ? 'CICLO_A' : 'CICLO_B',
        vacuum_lines: 2,
        tools: [
          {
            id: `perf-tool-${i}`,
            width: 300 + Math.random() * 500,
            height: 400 + Math.random() * 600,
            weight: 5 + Math.random() * 20
          }
        ]
      })),
      selected_cycles: ['CICLO_A', 'CICLO_B'],
      elevated_tools: []
    };

    const startTime = Date.now();
    const optimizationResponse = await fetch(`${OPTIMIZATION_SERVICE_URL}/optimization/execute`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(perfTestData)
    });

    const executionTime = Date.now() - startTime;

    if (!optimizationResponse.ok) {
      throw new Error(`Ottimizzazione fallita: ${optimizationResponse.status}`);
    }

    const result = await optimizationResponse.json();
    log(`   ‚úì Ottimizzazione completata in ${executionTime}ms`, 'green');
    log(`   ‚úì Batch creati: ${result.batches.length}`, 'green');
    log(`   ‚úì ODL posizionati: ${result.total_odls_placed}/${result.total_odls_input}`, 'green');
    log(`   ‚úì Success rate: ${(result.success_rate * 100).toFixed(1)}%`, 'green');

    // Calcola efficienza media
    const avgEfficiency = result.batches.reduce((sum: number, b: any) => 
      sum + b.metrics.area_efficiency, 0) / result.batches.length;
    log(`   ‚úì Efficienza media: ${(avgEfficiency * 100).toFixed(1)}%`, 'green');

    // Test 5: Verifica Integrazione App Next.js
    log('\n5. Test integrazione con app Next.js...', 'yellow');
    log('   ‚ÑπÔ∏è  Per test completo, avvia app e visita /autoclavi/optimization', 'blue');

    // Riepilogo
    log('\n=== RIEPILOGO TEST ===', 'magenta');
    log('‚úÖ Health check microservizio: OK', 'green');
    log('‚úÖ Connessione database: OK', 'green');
    log('‚úÖ API analisi cicli: OK', 'green');
    log('‚úÖ API ottimizzazione: OK', 'green');
    log(`‚úÖ Performance: ${executionTime}ms per ${perfTestData.odls.length} ODL`, 'green');
    
    log('\nüìä Metriche Algoritmo:', 'blue');
    log(`   - Efficienza media batch: ${(avgEfficiency * 100).toFixed(1)}%`, 'blue');
    log(`   - Tempo per ODL: ${(executionTime / perfTestData.odls.length).toFixed(1)}ms`, 'blue');
    log(`   - Success rate: ${(result.success_rate * 100).toFixed(1)}%`, 'blue');

  } catch (error) {
    log(`\n‚ùå ERRORE: ${error}`, 'red');
    
    if (error instanceof Error && error.message.includes('ECONNREFUSED')) {
      log('\n‚ö†Ô∏è  Il microservizio non √® in esecuzione!', 'yellow');
      log('   Avvia con: cd manta-optimization-service && ./run.sh', 'yellow');
    }
  } finally {
    await prisma.$disconnect();
  }
}

// Esegui test
testOptimizationService().catch(console.error);